name: Deploy to EC2

on:
  push:
    branches: [main, production, staging]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production

env:
  NODE_VERSION: '20'

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run check
        continue-on-error: true

      - name: Run tests
        run: npm test
        env:
          DATABASE_URL: ${{ secrets.TEST_DATABASE_URL }}
          SESSION_SECRET: test-secret
          TMDB_API_KEY: ${{ secrets.TMDB_API_KEY }}
          TMDB_ACCESS_TOKEN: ${{ secrets.TMDB_ACCESS_TOKEN }}
          CLOUDINARY_CLOUD_NAME: ${{ secrets.CLOUDINARY_CLOUD_NAME }}
          CLOUDINARY_API_KEY: ${{ secrets.CLOUDINARY_API_KEY }}
          CLOUDINARY_API_SECRET: ${{ secrets.CLOUDINARY_API_SECRET }}

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build
        env:
          NODE_ENV: production

      - name: Create deployment package
        run: |
          tar -czf deploy.tar.gz \
            dist/ \
            package.json \
            package-lock.json \
            drizzle.config.ts \
            shared/ \
            server/services/ \
            server/utils/

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}
          path: deploy.tar.gz
          retention-days: 7

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: ${{ github.ref == 'refs/heads/production' && 'production' || (github.ref == 'refs/heads/staging' && 'staging' || 'staging') }}
      url: ${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_URL || secrets.STAGING_URL }}
    
    env:
      ENVIRONMENT: ${{ github.ref == 'refs/heads/production' && 'production' || (github.ref == 'refs/heads/staging' && 'staging' || 'staging') }}
      EC2_HOST: ${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_EC2_HOST || secrets.STAGING_EC2_HOST }}
      EC2_USER: ${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_EC2_USER || secrets.STAGING_EC2_USER }}
      EC2_SSH_KEY: ${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_EC2_SSH_KEY || secrets.STAGING_EC2_SSH_KEY }}
      APP_DIR: ${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_APP_DIR || secrets.STAGING_APP_DIR }}
    
    steps:
      - name: Set deployment info
        id: deployment-info
        run: |
          echo "environment=${{ env.ENVIRONMENT }}" >> $GITHUB_OUTPUT
          echo "timestamp=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_OUTPUT
          echo "commit_sha=${GITHUB_SHA:0:7}" >> $GITHUB_OUTPUT
          echo "deployer=${{ github.actor }}" >> $GITHUB_OUTPUT

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: deployment-package-${{ github.sha }}

      - name: Configure SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ env.EC2_SSH_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ env.EC2_HOST }} >> ~/.ssh/known_hosts

      - name: Pre-deployment health check
        run: |
          echo "Checking current application status..."
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}/api/health || echo "000")
          echo "Current health status: $RESPONSE"

      - name: Transfer deployment package
        run: |
          echo "Transferring deployment package to ${{ env.ENVIRONMENT }}..."
          scp -i ~/.ssh/deploy_key deploy.tar.gz ${{ env.EC2_USER }}@${{ env.EC2_HOST }}:/tmp/deploy-${{ github.sha }}.tar.gz

      - name: Deploy on EC2
        id: deploy
        run: |
          echo "Starting deployment to ${{ env.ENVIRONMENT }}..."
          ssh -i ~/.ssh/deploy_key ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << 'ENDSSH'
            set -e
            
            # Configuration
            APP_DIR="${{ env.APP_DIR }}"
            DEPLOY_PACKAGE="/tmp/deploy-${{ github.sha }}.tar.gz"
            ENVIRONMENT="${{ env.ENVIRONMENT }}"
            
            echo "==========================================="
            echo "CineHub Pro Deployment"
            echo "Environment: $ENVIRONMENT"
            echo "Time: $(date)"
            echo "Commit: ${{ github.sha }}"
            echo "==========================================="
            
            # Navigate to app directory
            cd $APP_DIR || { echo "App directory not found!"; exit 1; }
            
            # Create comprehensive backup
            echo "Creating backup..."
            BACKUP_DIR="backups/backup-$(date +%Y%m%d-%H%M%S)"
            mkdir -p $BACKUP_DIR
            
            if [ -d "dist" ]; then
              cp -r dist $BACKUP_DIR/ 2>/dev/null || echo "No dist to backup"
            fi
            
            if [ -f "package.json" ]; then
              cp package.json $BACKUP_DIR/ 2>/dev/null || echo "No package.json to backup"
            fi
            
            # Keep only last 5 backups
            ls -dt backups/backup-* | tail -n +6 | xargs rm -rf 2>/dev/null || true
            echo "Backup created at $BACKUP_DIR"
            
            # Extract new version
            echo "Extracting deployment package..."
            tar -xzf $DEPLOY_PACKAGE || { echo "Failed to extract package!"; exit 1; }
            
            # Install production dependencies
            echo "Installing dependencies..."
            npm ci --production --ignore-scripts || { echo "Failed to install dependencies!"; exit 1; }
            
            # Run database migrations
            echo "Running database migrations..."
            npm run db:push 2>&1 | tee migration.log || {
              echo "‚ö†Ô∏è  Migration had warnings (check migration.log)"
            }
            
            # Check if PM2 is available
            if ! command -v pm2 &> /dev/null; then
              echo "Installing PM2..."
              npm install -g pm2
            fi
            
            # Restart application with PM2
            echo "Restarting application..."
            if pm2 describe cinehub-pro-$ENVIRONMENT > /dev/null 2>&1; then
              echo "Restarting existing PM2 process..."
              pm2 restart cinehub-pro-$ENVIRONMENT --update-env
            else
              echo "Starting new PM2 process..."
              pm2 start npm --name "cinehub-pro-$ENVIRONMENT" -- start
            fi
            
            # Save PM2 configuration
            pm2 save
            
            # Set PM2 to start on system boot (if not already done)
            pm2 startup || echo "PM2 startup already configured"
            
            # Clean up deployment package
            rm -f $DEPLOY_PACKAGE
            
            echo "==========================================="
            echo "‚úÖ Deployment completed successfully!"
            echo "==========================================="
          ENDSSH

      - name: Post-deployment health check
        id: health-check
        run: |
          echo "Waiting for application to start..."
          sleep 20
          
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Health check attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}/api/health || echo "000")
            
            if [ "$RESPONSE" = "200" ]; then
              echo "‚úÖ Health check passed - Application is running"
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "‚ö†Ô∏è  Health check returned: $RESPONSE"
            RETRY_COUNT=$((RETRY_COUNT + 1))
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Retrying in 10 seconds..."
              sleep 10
            fi
          done
          
          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          echo "status=failed" >> $GITHUB_OUTPUT
          exit 1

      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'success'
        run: |
          echo "‚ö†Ô∏è  Deployment failed, initiating rollback..."
          ssh -i ~/.ssh/deploy_key ${{ env.EC2_USER }}@${{ env.EC2_HOST }} << 'ENDSSH'
            APP_DIR="${{ env.APP_DIR }}"
            cd $APP_DIR
            
            # Find most recent backup
            LATEST_BACKUP=$(ls -dt backups/backup-* | head -1)
            
            if [ -d "$LATEST_BACKUP" ]; then
              echo "Rolling back to $LATEST_BACKUP..."
              
              # Restore backup
              if [ -d "$LATEST_BACKUP/dist" ]; then
                rm -rf dist
                cp -r $LATEST_BACKUP/dist .
              fi
              
              if [ -f "$LATEST_BACKUP/package.json" ]; then
                cp $LATEST_BACKUP/package.json .
              fi
              
              # Restart application
              pm2 restart cinehub-pro-${{ env.ENVIRONMENT }} || pm2 start npm --name "cinehub-pro-${{ env.ENVIRONMENT }}" -- start
              
              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback!"
              exit 1
            fi
          ENDSSH

      - name: Verify rollback
        if: failure() && steps.deploy.outcome == 'success'
        run: |
          echo "Verifying rollback..."
          sleep 10
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" http://${{ env.EC2_HOST }}/api/health || echo "000")
          
          if [ "$RESPONSE" = "200" ]; then
            echo "‚úÖ Rollback successful - Application restored"
          else
            echo "‚ùå Rollback verification failed - Manual intervention required"
            exit 1
          fi

      - name: Cleanup SSH
        if: always()
        run: rm -f ~/.ssh/deploy_key

  notify:
    name: Send Deployment Notification
    runs-on: ubuntu-latest
    needs: [deploy]
    if: always()
    
    steps:
      - name: Deployment notification
        run: |
          ENVIRONMENT="${{ github.ref == 'refs/heads/production' && 'production' || 'staging' }}"
          STATUS="${{ needs.deploy.result }}"
          
          if [ "$STATUS" = "success" ]; then
            echo "üéâ Deployment to $ENVIRONMENT successful!"
            echo "üì¶ Version: ${{ github.sha }}"
            echo "üë§ Deployed by: ${{ github.actor }}"
            echo "üîó URL: http://${{ github.ref == 'refs/heads/production' && secrets.PRODUCTION_EC2_HOST || secrets.STAGING_EC2_HOST }}"
          else
            echo "‚ùå Deployment to $ENVIRONMENT failed!"
            echo "üì¶ Version: ${{ github.sha }}"
            echo "üë§ Attempted by: ${{ github.actor }}"
            echo "Please check the logs and try again."
            exit 1
          fi

      # Optional: Slack notification (uncomment and configure)
      # - name: Slack notification
      #   if: always()
      #   uses: 8398a7/action-slack@v3
      #   with:
      #     status: ${{ needs.deploy.result }}
      #     text: |
      #       Deployment to ${{ github.ref == 'refs/heads/production' && 'production' || 'staging' }}
      #       Status: ${{ needs.deploy.result }}
      #       Commit: ${{ github.sha }}
      #       Deployed by: ${{ github.actor }}
      #     webhook_url: ${{ secrets.SLACK_WEBHOOK }}
      #   env:
      #     SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
