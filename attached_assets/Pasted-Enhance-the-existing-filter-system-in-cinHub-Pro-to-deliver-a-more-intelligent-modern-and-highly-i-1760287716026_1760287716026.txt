Enhance the existing filter system in cinHub-Pro to deliver a more intelligent, modern, and highly interactive filtering experience across movies and TV content. The new design should combine both simplicity and power — a clean, intuitive interface for casual users and an advanced view for enthusiasts. Implement a two-tier filter UI: (1) a compact floating bar or sticky top row with quick chips for common filters (genre, rating, release year, language, sort by) and (2) an expandable “Advanced Filters” sheet or side drawer for deeper criteria like production companies, cast, streaming providers, certifications, monetization types, runtime range, and release date range. Each filter element should use dynamic data (fetched from TMDB or internal endpoints), support multi-select, show selection state clearly, and be fully responsive. Add contextual helper text and live result counts (“showing 423 results”) that update in real time as filters change, without full page reloads. Improve the debouncing behavior to instantly reflect user interactions while minimizing API calls, include a subtle inline loader or shimmer effect while results update, and make filters persist between sessions using localStorage and URL query parameters. Add accessibility enhancements: all filter controls must be keyboard navigable, have clear ARIA labels, visible focus rings, and polite screen-reader announcements when filters are applied or cleared. Provide an “Undo Reset” snackbar when the user resets all filters. Introduce intelligent defaults: highlight trending genres, pre-select the user’s preferred language or region, and support saving named filter presets (e.g., “My Sci-Fi Picks”). The design language should match cinHub-Pro’s cinematic aesthetic — glassmorphism, rounded edges, motion blur, and soft gradients — using Tailwind variables from the existing theme. The UX goal is to make filtering feel fast, smart, and rewarding: users should see meaningful visual feedback with every interaction, have a clear sense of what’s applied, and never lose context while exploring the catalog. Finally, the implementation must maintain full type safety (no any), use memoization to prevent unnecessary renders, support keyboard shortcuts (e.g., press “F” to open filters), and provide extensibility so new filter types can be added with minimal effort.